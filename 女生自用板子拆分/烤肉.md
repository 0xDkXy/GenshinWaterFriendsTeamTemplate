# 定义
| 符号 | 注释 |
| :--- | :--- |
| evenlevel | 最小偶长度路径长度 |
| oddlevel | 最小奇长度路径长度 |
| level | 上两者的最小值 |
| outer | 一个节点被认为是outer当且仅当奇level为偶数 |
| inner | 一个节点被认为是inner当且仅当奇level为奇数 |
| other level | 若level为oddlevel，则other level为evenlevel，若level为evenlevel，则other level为oddlevel |
| bridge | 边(u, v)为桥当且仅当两者evenlevel都有限或oddlevel都有限（注意和图论中桥的传统意义不同） |

> 注意，由于增广路P是奇数长度的边，所有P中的边都是桥。如果存在桥(u, v)，那么存在一些节点(至少是u和v)的evenlevel**和**oddlevel是有限的。

我们现在解释一个概念*tenacity of a bridge*(直译为桥的强度):
> 式中M为Given matching，即给定的匹配

$$
if \ edge(u, v) \notin M \\
tenacity(u, v) = evenlevel(u)+evenlevel(v)+1 \\
if \ edge(u,v) \in M \\
tenacity(u, v) = oddlevel(u)+oddlevel(v)+1
$$

所以，一个*桥*的*强度*代表了一个经过桥的从一个自由节点到另外一个自由节点的最短的**不一定是简单路**的可选路。如果路径是简单的，那么它是一条增广路。可以被证明对于任何最小增广路P其经过一条强度等于P的长度的桥。

> 自由节点：未匹配的节点

# 算法特点

本算法包括一个主过程`SEARCH` (搜索)，三个子过程`BLOSS-AUG` (开花增广)，`FINDPATH` (寻路)和`TOPOLOGICAL ERASE` (拓扑删除)

对于每个阶段，`SEARCH`构建一个以图G中自由节点为根的BFS树以寻找每个G中节点的level。即为每个outer节点计算evenlevel，为inner节点计算oddlevel。`SEARCH`过程开始于level 0并且每次随着BFS树的生长让level+1。

当`SEARCH`发现一条`桥(u, v)`时，它会以参数`(u, v)`调用`BLOSS-AUG`。如果存在一条增广路包括`(u, v)`，它的长度会至少是`桥(u, v)`的`强度`。事实上，当`BLOSS-AUG`被以参数`(u, v)`调用时，它会寻找一条长度严格等于`桥(u, v)强度`的增广路。所以，当`BLOSS-AUG`被用于一个更低的搜索level处理一个更低`强度`的桥时，**整个过程中**第一个找到的增广路会是最短的。实际上，`SEARCH`在level i使用`BLOSS-AUG`扫描`强度`等于2i-1的桥时，会把他们全塞进一个集合里，然后在level i的搜索结束之前，将集合里面的桥一个个拿出来丢给`BLOSS-AUG`进行处理。

当不存在长度等于`(u, v)强度`且经过`桥(u, v)`的增广路时，`BLOSS-AUG`会创建一朵新的`blossom` (花，表示一个点集) B。在调用之前，每个B中的节点一定的有限level值（在`SEARCH`中赋予过）。在本次的调用中，`BLOSS-AUG`会将B中所有顶点的`other level`值设置为一个有限值。在这个过程中，可能会发现有些边是`桥`，然后这些`桥`的`强度`可以被算出来，并根据`强度`加入到适当的桥的集合中。

当`BLOSS-AUG`发现一条经过`(u, v)`的增广路时，`FINDPATH`会找到一条路P，使当前匹配沿着这条路增加；然后`TOPOLOGICAL ERASE`会从P中删掉当前阶段不能成为一条不相交的最小增广路的边。在一个阶段中，若一条最小增广路被以level为m的搜索过程中找到，那么一个不相交的长度为2m+1的增广路的集合会在同一个搜索level被找出来，此时阶段结束。`TOPOLOGICAL ERASE`的设计是为了保证这些路径不相交。阶段结束即不存在其他`强度`为2m+1的桥这个条件确保了当前找到的最短增广路的集合是最大的。因此，正如所说，每条最短增广路P经过一条`强度`等于P的桥。

由于算法执行一个阶段需要$O(|E|)$步，它寻找最大匹配需要$O(\sqrt{|V|}*|E|)$步


# `SEARCH`详解

在一个阶段的执行中，`SEARCH`扩展以G中自由节点为根的BFS树来寻找每个节点的level值。

`SEARCH`扫描一条边最多一次（以其两个方向之一）。在`BLOSS-AUG`的处理之后，一条已经被搜索的边可能会在相反的方向被扫到。为了防止其发生，`BLOSS-AUG`会将边标记为`used` (已使用) 来禁止`SEARCH`重复扫描它。

在一个阶段的开始，每个G中节点的`oddlevel`和`evenlevel`被置位无穷，以表示尚未找到任何长度的可选路。然后，每个自由节点的`evenlevel`被置0。

当搜索level i为偶数时，对于每个满足`evenlevel(v)=i`的节点v，寻找节点u满足`边(v, u)`是`unused` (见前两段定义，尚未被使用的)并且尚未被匹配的。如果u的`odd level`是无限的，将其设为i+1。

当i为奇数时，对于每个满足`oddlevel(v)=i`的节点v，寻找其唯一匹配邻居u，并将u的`even level`置为i+1

扩展BFS树时，`SEARCH`对于每个已搜索节点u，构建一个它的`先辈`集合。

> 先辈：令u为G中一个非自由点，若u为inner且`oddlevel(u)=2i+1`，那么v是u的先辈当且仅当`evenlevel(v)=2i`且`(u, v)`是E的成员（即给定的边集中包括`(u, v)`这条边）。若u为outer，那么v是u的先辈当且仅当`(u, v)`是一条匹配边。

关于u的先辈集合以`predecessors(u)`来表示。

> 祖先：先辈关系的传递非自反闭包。

补充一点，`SEARCH`同时对于每个inner节点u构建其`anomalies` (异常点？)集合。

> anomaly: 令u为一个inner节点满足`oddlevel(u)=2i+1`，那么v是u的一个anomaly(异常点？)当且仅当`evenlevel(v)>2i+1`且`(u, v)`是集合(E-M)的成员。

扫到一条边时，`SEARCH`首先检查它是不是桥。当`SEARCH`发现`边(u, v)`是桥时，它算出桥的强度，为2i+1，并将其插入桥集合`bridge(i)`中